using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace TFLandCOMP.Models
{
    public class Parser
    {
        private enum ParserState
        {
            Start,
            AfterConst,
            AfterIdentifier,
            AfterColon,
            AfterType,
            AfterEqual,
            AfterNumber,
            AfterSemicolon,
            Error
        }

        private readonly HashSet<string> declaredVariables = new HashSet<string>();
        private static readonly Regex FloatRegex = new Regex(@"^[+-]?\d+\.\d+$", RegexOptions.Compiled);
        private static readonly Regex CyrillicRegex = new Regex(@"\p{IsCyrillic}", RegexOptions.Compiled);

        public List<ErrorDetail> Parse(List<Token> tokens, string input)
        {
            var errors = new List<ErrorDetail>();
            var state = ParserState.Start;
            int pos = 0;

            while (pos < tokens.Count)
            {
                var token = tokens[pos];
                switch (state)
                {
                    case ParserState.Start:
                        // Проверка ключевого слова 'const'
                        if (token.Type == TokenType.CONST)
                        {
                            // Проверка пробела после const
                            if (token.MissingSpace)
                            {
                                AddError(errors, "E008", "Отсутствует пробел после 'const'.", token.StartIndex, input);
                            }
                            state = ParserState.AfterConst;
                            pos++;
                        }
                        else
                        {
                            // Если это не 'const', добавляем ошибку E001
                            AddError(errors, "E001", $"Ожидалось 'const', найдено '{token.Value}'.", token.StartIndex, input);
                            state = ParserState.AfterConst;
                            pos++;
                        }
                        break;

                    case ParserState.AfterConst:
                        // Проверка идентификатора
                        if (token.Type == TokenType.IDENTIFIER || token.Type == TokenType.INVALID_IDENTIFIER)
                        {
                            // Проверка валидности имени
                            if (token.Type == TokenType.INVALID_IDENTIFIER)
                            {
                                AddError(errors, "E014", $"Недопустимое имя: '{token.Value}'.", token.StartIndex, input);
                            }
                            // Проверка уникальности
                            else if (declaredVariables.Contains(token.Value))
                            {
                                AddError(errors, "E008", $"Переменная '{token.Value}' уже объявлена.", token.StartIndex, input);
                            }
                            else
                            {
                                declaredVariables.Add(token.Value);
                            }
                            state = ParserState.AfterIdentifier;
                            pos++;
                        }
                        else
                        {
                            AddError(errors, "E002", "Ожидался идентификатор.", token.StartIndex, input);
                            state = ParserState.AfterIdentifier;
                            pos++;
                        }
                        break;

                    case ParserState.AfterIdentifier:
                        if (token.Type == TokenType.COLON)
                        {
                            state = ParserState.AfterColon;
                            pos++;
                        }
                        else
                        {
                            AddError(errors, "E003", "Ожидалось ':' после имени.", token.StartIndex, input);
                            state = ParserState.AfterColon;
                            pos++;
                        }
                        break;

                    case ParserState.AfterColon:
                        // Проверка типа (только f32/f64)
                        if (token.Type == TokenType.TYPE && (token.Value == "f32" || token.Value == "f64"))
                        {
                            state = ParserState.AfterType;
                        }
                        else
                        {
                            AddError(errors, "E004", "Ожидался тип (f32/f64).", token.StartIndex, input);
                            state = ParserState.AfterType;
                        }
                        pos++;
                        break;

                    case ParserState.AfterType:
                        if (token.Type == TokenType.EQUAL)
                        {
                            state = ParserState.AfterEqual;
                            pos++;
                        }
                        else
                        {
                            AddError(errors, "E005", "Ожидалось '=' после типа.", token.StartIndex, input);
                            state = ParserState.AfterEqual;
                            pos++;
                        }
                        break;

                    case ParserState.AfterEqual:
                        if (token.Type == TokenType.NUMBER)
                        {
                            // Проверка формата числа (включая символы вроде @)
                            if (CyrillicRegex.IsMatch(token.Value) || !FloatRegex.IsMatch(token.Value))
                            {
                                AddError(errors, "E006", $"Неверный формат числа: '{token.Value}'.", token.StartIndex, input);
                            }
                            state = ParserState.AfterNumber;
                            pos++;
                        }
                        else
                        {
                            AddError(errors, "E006", "Ожидалось число.", token.StartIndex, input);
                            state = ParserState.AfterNumber;
                            pos++;
                        }
                        break;

                    case ParserState.AfterNumber:
                        if (token.Type == TokenType.SEMICOLON)
                        {
                            state = ParserState.AfterSemicolon;
                            pos++;
                        }
                        else
                        {
                            AddError(errors, "E007", "Ожидалось ';'.", token.StartIndex, input);
                            state = ParserState.AfterSemicolon;
                            pos++;
                        }
                        break;

                    case ParserState.AfterSemicolon:
                        state = ParserState.Start;
                        break;

                    case ParserState.Error:
                        // Пропускаем токены до следующего объявления
                        while (pos < tokens.Count && tokens[pos].Type != TokenType.CONST)
                            pos++;
                        if (pos < tokens.Count) state = ParserState.Start;
                        break;
                }
            }

            return errors;
        }

        private void AddError(List<ErrorDetail> errors, string code, string msg, int idx, string input)
        {
            errors.Add(new ErrorDetail
            {
                ErrorCode = code,
                ErrorMessage = msg,
                Position = GetLineAndColumn(input, idx)
            });
        }

        private static string GetLineAndColumn(string text, int index)
        {
            int line = 1, col = 1;
            for (int i = 0; i < index && i < text.Length; i++)
            {
                if (text[i] == '\n') { line++; col = 1; }
                else col++;
            }
            return $"Строка {line}, Колонка {col}";
        }
    }
}
